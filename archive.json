{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2026-01-18T00:39:53.940452+00:00",
  "repo": "ricktaylor/btpu",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDONqGLE87Ug9Nw",
      "title": "How to define number of metadata items in a message ?",
      "url": "https://github.com/ricktaylor/btpu/issues/1",
      "state": "CLOSED",
      "author": "EpicKiwi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 7.2 says that\n\n> If the 'M' flag is set in the Message header, the header is followed by one or more Metadata Items.\n\nSo 'M' flags indicates us if there is metadata items or not. But I can't find a way to compute the number of metadata items in a message. How to know if there is a second metadata item after the first or if it is the beginning of message content ? Maybe I'm missing something.",
      "createdAt": "2025-10-29T10:56:34Z",
      "updatedAt": "2025-11-05T14:36:45Z",
      "closedAt": "2025-11-05T14:36:45Z",
      "comments": [
        {
          "author": "ricktaylor",
          "authorAssociation": "OWNER",
          "body": "I have added an extra bit flag to each metadata item (now called Hint Item), to indicate if there is another Hint following.  This should fix the issue",
          "createdAt": "2025-11-05T14:36:45Z",
          "updatedAt": "2025-11-05T14:36:45Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDONqGLE87UhFim",
      "title": "Metadata field may increase protocol complexity",
      "url": "https://github.com/ricktaylor/btpu/issues/2",
      "state": "OPEN",
      "author": "EpicKiwi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Last commits includes metadata items in every message used for transmission.\nCurrently, only a single metadata type is defined (the \"Bundle Length Metadata Item\").\nIn my opinion, this optional information could be included in message content of a \"Transfert Start\" message without adding more complexity of every message in the whole protocol.\n\nIncreasing complexity means a lot more combination case to take into account during parsing.\nAnd some weird combinations like having a \"Bundle Length Metadata Item\" into a \"Transfert Cancel\" message.",
      "createdAt": "2025-10-29T11:05:34Z",
      "updatedAt": "2025-10-29T14:44:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ricktaylor",
          "authorAssociation": "OWNER",
          "body": "That wasn't what I was trying to mandate.\n\nAll metadata items are optional - think of them as hints that MAY be added (if the flag is set).\n\nBut I understand your underlying point... the generic \"here are some hints\" mechanism is more complex than adding a \"length\" filed to the Transfer Start.\n\nHowever, what if there is an out of order delivery?  It is entirely possible for the Transfer Start message to be lost and then retransmitted... perhaps a sender might include a Total Length hint in every 3rd segment?",
          "createdAt": "2025-10-29T13:18:03Z",
          "updatedAt": "2025-10-29T13:18:03Z"
        },
        {
          "author": "EpicKiwi",
          "authorAssociation": "NONE",
          "body": "I write this issue mainly for discussing about this topic, not because I strongly think that we should not include metadata into messages.\n\nI'm totally fine with having hints on some messages. And I think it's a good idea to give hints to help receiver collect data as fluently as possible.\n\nHints could be included in Transfer Start or Transfer Segment messages (for example) **content part** and leave every other messages without any mention of metadata. Those hints could be optional with the same mechanism as the one used by metadata in current state of the protocol. A flag or a length describing \"metadata part\".\n\n**Potential drawback I see**: It increase the size of every messages that may contains metadata (even those with no metadata field) since we may include a flag field or a length field. But, message's length field is longer and can describe bigger messages since we don't make use of 4 bits from length field to code flags.",
          "createdAt": "2025-10-29T14:44:08Z",
          "updatedAt": "2025-10-29T14:44:08Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDONqGLE87fadjH",
      "title": "Monotonically decreasing segment index may lead to less compact transfers",
      "url": "https://github.com/ricktaylor/btpu/issues/3",
      "state": "OPEN",
      "author": "climoge",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello. I'm trying to implement BTP Unidirectional. However I ran into a conflict between the bundle segmentation and the interleaving transfer of bundles of different priorities.\n\nIn the [Segmentation and Transfers](https://ricktaylor.github.io/btpu/draft-ietf-dtn-btpu-01/draft-ietf-dtn-btpu.html#name-segmentation-and-transfers) section, it's said that each segment is assigned a **monotonically decreasing** segment index. So when we send the first segment of a bundle we need to know the total number of segments for this bundle.\n\nHowever in [Segmentation of a sequence of Bundles of different priority](https://ricktaylor.github.io/btpu/draft-ietf-dtn-btpu-01/draft-ietf-dtn-btpu.html#name-segmentation-of-a-sequence-of) it's written that segments of different bundles may be interleaved if a bundle with an higher priority is queued for transmission.\n\nSo, in the hypothetic case below :\n\n```text\n                       +----------------+\n                       | Bundle C       |             High Priority\n                       +----------------+\n+--------------+-----------------+\n| Bundle A     | Bundle B        |                    Low Priority\n+--------------+-----------------+\n\n                       :                :         \n:              :                 :\n\n+--------------+-------+----------------+-----+----------------------+\n| Complete     | T1    | Complete       |  ?  |           ?          |\n| Bundle A     | S0    | Bundle C       |     |                      |\n+--------------+-------+----------------+-----+----------------------+\n\n:                      :                      :                      :\n\n+----------------------+----------------------+----------------------+\n| Link-layer PDU N     | Link-layer PDU N + 1 | Link-layer PDU N + 2 |\n+----------------------+----------------------+----------------------+\n```\n\nThere is two possibilities to fill the link-layer PDUs.\n\n# Possibility 1 (compatible with the current draft)\n\n```text\n                       +----------------+\n                       | Bundle C       |             High Priority\n                       +----------------+\n+--------------+-----------------+\n| Bundle A     | Bundle B        |                    Low Priority\n+--------------+-----------------+\n\n                       :                :         \n:              :                 :\n\n+--------------+-------+----------------+-----+----------+-----------+\n| Complete     | T1    | Complete       | Pad |    T1    |    Pad    |\n| Bundle A     | S0    | Bundle C       |     |    S1    |           |\n+--------------+-------+----------------+-----+----------+-----------+\n\n:                      :                      :                      :\n\n+----------------------+----------------------+----------------------+\n| Link-layer PDU N     | Link-layer PDU N + 1 | Link-layer PDU N + 2 |\n+----------------------+----------------------+----------------------+\n```\n\nWe split the `Bundle B` in two segments, the first filling up the first link-layer PDU (N). `Bundle C` with higher priority is queued, we send it as a complete bundle in the second link-layer PDU (N + 1).\nThe second segment of `Bundle B` doesn't fit in the remaining space of the second link-layer PDU (N + 1) so we fill it with a padding message and we send the second segment in a third link-layer PDU (N + 2).\n\n# Possibility 2 (incompatible with the current draft but more compact)\n\n```text\n                       +----------------+\n                       | Bundle C       |             High Priority\n                       +----------------+\n+--------------+-----------------+\n| Bundle A     | Bundle B        |                    Low Priority\n+--------------+-----------------+\n\n                       :                :         \n:              :                 :\n\n+--------------+-------+----------------+-----+-----+----------------+\n| Complete     | T1    | Complete       | T1  | T1  |    Pad         |\n| Bundle A     | S0    | Bundle C       | S1  | S2  |                |\n+--------------+-------+----------------+-----+-----+----------------+\n\n:                      :                      :                      :\n\n+----------------------+----------------------+----------------------+\n| Link-layer PDU N     | Link-layer PDU N + 1 | Link-layer PDU N + 2 |\n+----------------------+----------------------+----------------------+\n```\n\nWe create a first segment for `Bundle B` to fill the first link-layer PDU (N). `Bundle C` with higher priority is queued, we send it as a complete bundle in the second link-layer PDU (N + 1).\nThen we create a second segment for `Bundle B` to fill the second link-layer PDU (N + 1) and we create a third and last segment for `Bundle B` to send in the third link-layer PDU (N + 2).\n\n# Pro and cons of each possibility\n\nThe first possibility allows to have a monotically decreasing segment index but is less data compact in certain situation (e.g: a `Bundle D` that could fit in one **bundle message** in `Link-layer PDU N + 2` of the second possibility but would need a fourth link-layer PDU (N + 3) in the first possibility).\n\nThe second possibility is the most compact and permits to fill the third link-layer PDU (N + 2) with a larger **bundle message** but we can't know in advance the total number of segments for `Bundle B` so we can't assign a monotically decreasing segment index.\n\n# My question\n\nDo we stick to the current **monotically decreasing segment index** or do we need to change the segment identification method to allow more compact transfers ?\n\nThere is also the possibility that I did not fully understand the draft.\n",
      "createdAt": "2025-12-19T17:31:09Z",
      "updatedAt": "2025-12-19T17:31:09Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": []
}